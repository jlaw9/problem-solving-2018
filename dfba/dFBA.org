* Legacy                                                           :noexport:
** Defining Dynamic FBA model for a single species
*** Import headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 %matplotlib inline
 import cobra
 import PyDSTool as dst
 import pandas as pd
 import matplotlib.pyplot as plt
 import copy
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[1]:
 :END:
*** File Paths for Media spec and FBA model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer 
 model = cobra.io.read_sbml_model('./data/Bacteroides_sp_1_1_14.xml')
 mediaFluxes = pd.read_csv('./data/VMH_HighFiber.tsv', sep='\t')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[3]:
 :END:
*** Extract exchange reactions into variable definition and ics dictionary
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   def cleanupname(name):
       """
       The reaction names in the model files 
       don't have brackets or parentheses. I replaced
       those found in the mediaFluxes file.
       """
       name = name.replace('[', '_LPAREN_')
       name = name.replace(']', '_RPAREN_')
       name = name.replace('(', '_LPAREN_')
       name = name.replace(')', '_RPAREN_')
       return name

   """
   Initialize dictionaries for defining the ODE variables for a 
   single species
   """
   VarDef = dict()
   ParDef_base = dict()
   ICS_base = dict()

   solution = model.optimize() # Get fluxes
   all_exchanges = model.exchanges
   media_derived_components = dict()

   exchange_reaction_ids = [rxn.id for rxn in all_exchanges]
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[4]:
 :END:

**** Extract the reaction names and flux values into a dictionary.
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 for i, row in mediaFluxes.iterrows():
     N = cleanupname(row.Reaction)
     if N in exchange_reaction_ids:
         media_derived_components[N] = row['Flux Value'] / (24.0*60.0) # Per minute

 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[51]:
 :END:

**** Get the outfluxes
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 out_fluxes = []
 for k in all_exchanges:
     if k.reversibility and k.id not in media_derived_components.keys():
         out_fluxes.append(k.id)

 ParDef_base['mu'] = solution.objective_value/60.0
 VarDef['X'] =  'mu * X'
 ICS_base['X'] = 1e-1
 for r in all_exchanges:
     if r.id in media_derived_components.keys():
         ParDef_base[r.id + '_influx'] = media_derived_components[r.id]
         ParDef_base[r.id + '_consumption'] = solution.fluxes[r.id]
         ICS_base[r.id] = media_derived_components[r.id]
         VarDef[r.id] = r.id + '_influx + ' + r.id + '_consumption' + ' * X'
     if r.id in out_fluxes:
         ParDef_base[r.id + '_outflux'] = solution.fluxes[r.id] 
         VarDef[r.id] = r.id + '_outflux * X'
         ICS_base[r.id] = 0.0
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[52]:
 :END:

*** Define PyDSTool Model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
   TSPAN = 5

   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   def simulateModel(ModelDS, ParDef, ICS, TSPAN, tstart):
       ModelDS.set(ics=ICS ,pars=ParDef,tdata=[tstart, tstart + TSPAN])
       P = ModelDS.compute('test').sample(dt=0.1)
       return(P)
   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   ModelDef =dst.args(name='Bacteroides',
                     varspecs=VarDef,
                     pars=ParDef,
                     ics=ICS,
                     )

   ModelDS = dst.Vode_ODEsystem(ModelDef)

   P = simulateModel(ModelDS, ParDef, ICS,TSPAN, 0.0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[53]:
 :END:

*** Create Upperlimit
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   AllPoints = []
   AllPoints.append(P)
   OriginalLB = {}
   model_copy = copy.deepcopy(model)
   T0=TSPAN

   for r in model_copy.reactions:
       if r in model_copy.exchanges:
           OriginalLB[r.id] = r.lower_bound

   for i in range(0, 10):
       print(T0)
       solution = model_copy.optimize()
       all_exchanges = model_copy.exchanges
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
               model_copy.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*P[r.id][-1]/(0.0005+P[r.id][-1])
               if r.id == 'EX_glu_L_LPAREN_e_RPAREN_':
                   print(r.id + ': ' +str(OriginalLB[r.id]) + ' -> ' + str(model_copy.reactions.get_by_id(r.id).lower_bound))
       solution = model_copy.optimize()
    #   print('mu= ' +str(solution.objective_value))
       ParDef['mu'] = solution.objective_value/60.0
       ICS['X'] = P['X'][-1]
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
                  if P[r.id][-1] < 0.0:
                      ICS[r.id] = 0.0
                  else:
    
                      ParDef[r.id + '_influx'] = media_derived_components[r.id]
                      ParDef[r.id + '_consumption'] = solution.fluxes[r.id]
                      ICS[r.id] = P[r.id][-1]
           if r.id in out_fluxes:
               ParDef[r.id + '_outflux'] = solution.fluxes[r.id] 
               ICS[r.id] = P[r.id][-1] # 0.0
       del P
       P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
   #    print('EX_glu_L_LPAREN_e_RPAREN_' + str(P['EX_glu_L_LPAREN_e_RPAREN_'][-1]))
       T0 += TSPAN

       AllPoints.append(P)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[54]:
 :END:



*** Results
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/metabolite-traj-1e-3.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:
                   if 'h2o' not in v :
                           T = P['t']
                           X = P[v]
                           plt.plot(T,X)
                   # T = P['t']
                   # X = P['X']
                   # plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('mmol')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[55]:
 : Text(0,0.5,u'mmol')
 [[file:./obipy-resources/metabolite-traj-1e-3.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/biomass-1e-1.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:

                   T = P['t']
                   X = P['X']
                   plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('gdw')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[56]:
 : Text(0,0.5,u'gdw')
 [[file:./obipy-resources/biomass-1e-1.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
 len(VarDef.keys())
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[10]:
 : 59
 :END:
** Defining Dynamic FBA model for multiple species
 <2018-04-12 Thu>
*** Import headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 %matplotlib inline
 import cobra
 import PyDSTool as dst
 import pandas as pd
 import matplotlib.pyplot as plt
 import copy
 import sys
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[40]:
 :END:
*** File Paths for Media spec and FBA model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer 
 PATH = '/home/cerevisaj/Documents/VT/Problem-Solving/problem-solving-2018/dfba'
 model = cobra.io.read_sbml_model(PATH + '/data/Bacteroides_sp_1_1_14.xml')
 mediaFluxes = pd.read_csv(PATH + '/data/VMH_HighFiber.tsv', sep='\t')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[44]:
 :END:
*** Extract exchange reactions into variable definition and ics dictionary
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   def cleanupname(name):
       """
       The reaction names in the model files 
       don't have brackets or parentheses. I replaced
       those found in the mediaFluxes file.
       """
       name = name.replace('[', '_LPAREN_')
       name = name.replace(']', '_RPAREN_')
       name = name.replace('(', '_LPAREN_')
       name = name.replace(')', '_RPAREN_')
       return name

   """
   Initialize dictionaries for defining the ODE variables for a 
   single species
   """
   VarDef = dict()
   ParDef_base = dict()
   ICS_base = dict()

   solution = model.optimize() # Get fluxes
   all_exchanges = model.exchanges
   media_derived_components = dict()

   exchange_reaction_ids = [rxn.id for rxn in all_exchanges]
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[50]:
 :END:

**** Extract the reaction names and flux values into a dictionary.
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 for i, row in mediaFluxes.iterrows():
     N = cleanupname(row.Reaction)
     if N in exchange_reaction_ids:
         media_derived_components[N] = row['Flux Value'] / (24.0*60.0) # Per minute

 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[51]:
 :END:

**** Get the outfluxes
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 out_fluxes = []
 for k in all_exchanges:
     if k.reversibility and k.id not in media_derived_components.keys():
         out_fluxes.append(k.id)

 ParDef_base['mu'] = solution.objective_value/60.0
 VarDef['X'] =  'mu * X'
 ICS_base['X'] = 1e-1
 for r in all_exchanges:
     if r.id in media_derived_components.keys():
         ParDef_base[r.id + '_influx'] = media_derived_components[r.id]
         ParDef_base[r.id + '_consumption'] = solution.fluxes[r.id]
         ICS_base[r.id] = media_derived_components[r.id]
         VarDef[r.id] = r.id + '_influx + ' + r.id + '_consumption' + ' * X'
     if r.id in out_fluxes:
         ParDef_base[r.id + '_outflux'] = solution.fluxes[r.id] 
         VarDef[r.id] = r.id + '_outflux * X'
         ICS_base[r.id] = 0.0
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[52]:
 :END:

*** Define PyDSTool Model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
   TSPAN = 5

   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   def simulateModel(ModelDS, ParDef, ICS, TSPAN, tstart):
       ModelDS.set(ics=ICS ,pars=ParDef,tdata=[tstart, tstart + TSPAN])
       P = ModelDS.compute('test').sample(dt=0.1)
       return(P)
   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   ModelDef =dst.args(name='Bacteroides',
                     varspecs=VarDef,
                     pars=ParDef,
                     ics=ICS,
                     )

   ModelDS = dst.Vode_ODEsystem(ModelDef)

   P = simulateModel(ModelDS, ParDef, ICS,TSPAN, 0.0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[53]:
 :END:

*** Create Upperlimit
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   AllPoints = []
   AllPoints.append(P)
   OriginalLB = {}
   model_copy = copy.deepcopy(model)
   T0=TSPAN

   for r in model_copy.reactions:
       if r in model_copy.exchanges:
           OriginalLB[r.id] = r.lower_bound

   for i in range(0, 10):
       print(T0)
       solution = model_copy.optimize()
       all_exchanges = model_copy.exchanges
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
               model_copy.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*P[r.id][-1]/(0.0005+P[r.id][-1])
               if r.id == 'EX_glu_L_LPAREN_e_RPAREN_':
                   print(r.id + ': ' +str(OriginalLB[r.id]) + ' -> ' + str(model_copy.reactions.get_by_id(r.id).lower_bound))
       solution = model_copy.optimize()
    #   print('mu= ' +str(solution.objective_value))
       ParDef['mu'] = solution.objective_value/60.0
       ICS['X'] = P['X'][-1]
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
                  if P[r.id][-1] < 0.0:
                      ICS[r.id] = 0.0
                  else:
    
                      ParDef[r.id + '_influx'] = media_derived_components[r.id]
                      ParDef[r.id + '_consumption'] = solution.fluxes[r.id]
                      ICS[r.id] = P[r.id][-1]
           if r.id in out_fluxes:
               ParDef[r.id + '_outflux'] = solution.fluxes[r.id] 
               ICS[r.id] = P[r.id][-1] # 0.0
       del P
       P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
   #    print('EX_glu_L_LPAREN_e_RPAREN_' + str(P['EX_glu_L_LPAREN_e_RPAREN_'][-1]))
       T0 += TSPAN

       AllPoints.append(P)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[54]:
 :END:



*** Results
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/metabolite-traj-1e-3.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:
                   if 'h2o' not in v :
                           T = P['t']
                           X = P[v]
                           plt.plot(T,X)
                   # T = P['t']
                   # X = P['X']
                   # plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('mmol')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[55]:
 : Text(0,0.5,u'mmol')
 [[file:./obipy-resources/metabolite-traj-1e-3.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/biomass-1e-1.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:

                   T = P['t']
                   X = P['X']
                   plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('gdw')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[56]:
 : Text(0,0.5,u'gdw')
 [[file:./obipy-resources/biomass-1e-1.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
 len(VarDef.keys())
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[10]:
 : 59
 :END:
* Current
* Final Definition of Single Species model
** Headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
%matplotlib inline
import cobra
import PyDSTool as dst
import pandas as pd
import matplotlib.pyplot as plt
import copy
import sys
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[1]:
 :END:

** Paths to data
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
model = cobra.io.read_sbml_model('./data/Bacteroides_sp_1_1_14.xml')
mediaFluxes = pd.read_csv('./data/VMH_HighFiber.tsv', sep='\t')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
:END:

** Read file
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
def cleanupname(name):
    """
    The reaction names in the model files 
    don't have brackets or parentheses. I replaced
    those found in the mediaFluxes file.
    """
    name = name.replace('[', '_LPAREN_')
    name = name.replace(']', '_RPAREN_')
    name = name.replace('(', '_LPAREN_')
    name = name.replace(')', '_RPAREN_')
    return name

"""
Initialize dictionaries for defining the ODE variables for a 
single species
"""

VarDef = dict()
ParDef_base = dict()
ICS_base = dict()

solution = model.optimize() # Get fluxes
all_exchanges = model.exchanges
media_derived_components = dict()

exchange_reaction_ids = [rxn.id for rxn in all_exchanges]
#+END_SRC

** Extract reactions+names
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
for i, row in mediaFluxes.iterrows():
    N = cleanupname(row.Reaction)
    if N in exchange_reaction_ids:
        media_derived_components[N] = row['Flux Value'] / (24.0*60.0) # Per minute
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[12]:
:END:

** Simulate
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t

ParDef_base['mu'] = solution.objective_value/60.0
VarDef['X'] =  'mu * X'
ICS_base['X'] = 1e-1

for r in all_exchanges:
    ParDef_base[r.id + '_Bact'] = solution.fluxes[r.id]
    if r.id in media_derived_components.keys():
        ParDef_base[r.id + '_influx'] = media_derived_components[r.id]
        VarDef[r.id] = r.id + '_influx +' + r.id + '_Bact' + ' * X'
    else: 
        VarDef[r.id] =  r.id + '_Bact' + ' * X'
    ICS_base[r.id] = 1

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
:END:

** Define Dynamical model
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
TSPAN = 5

ParDef = copy.deepcopy(ParDef_base)
ICS = copy.deepcopy(ICS_base)
def simulateModel(ModelDS, ParDef, ICS, TSPAN, tstart):
    ModelDS.set(ics=ICS ,pars=ParDef,tdata=[tstart, tstart + TSPAN])
    P = ModelDS.compute('test').sample(dt=0.1)
    return(P)
ParDef = copy.deepcopy(ParDef_base)
ICS = copy.deepcopy(ICS_base)
ModelDef =dst.args(name='Bacteroides',
                  varspecs=VarDef,
                  pars=ParDef,
                  ics=ICS,
                  )

ModelDS = dst.Vode_ODEsystem(ModelDef)
P= {}
for k in ICS_base.keys():
    P[k] = [ICS_base[k]]
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[15]:
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  AllPoints = []

  OriginalLB = {}
  model_copy = copy.deepcopy(model)
  T0=0

  for r in model_copy.reactions:
      if r in model_copy.exchanges:
          OriginalLB[r.id] = r.lower_bound

  for i in range(0, 2):
      print(T0)
      all_exchanges = model_copy.exchanges
      for r in all_exchanges:
          model_copy.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*P[r.id][-1]/(0.0005+P[r.id][-1])

          # if r.id == 'EX_adn_L_LPAREN_e_RPAREN_':
          #     print(r.id + ': ' +str(OriginalLB[r.id]) + ' -> ' + str(model_copy.reactions.get_by_id(r.id).lower_bound))
      solution = model_copy.optimize()
      ParDef['mu'] = solution.objective_value/60.0
      ICS['X'] = P['X'][-1]
      for r in all_exchanges:
          ParDef_base[r.id + '_Bact'] = solution.fluxes[r.id]
          ICS[r.id] = P[r.id][-1]
      P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
      TSTOP = T0+TSPAN
      AllNegativeValues = {}
      for variable in VarDef.keys():

          if P[variable][-1] < 0.0:
              AllNegativeValues = {key:P['t'][P[variable].index(value)] for value in P[variable] if P[variable] < 0.0 }
              # for p in P[variable]:
              #     if p < 0.0:
              #         AllNegativeValues[variable] = P['t'][index]
              #         break
              #     index += 1
              # for i in range(0, len(P[variable])):
              #     if P[variable][i] < 0.0:
              #         if P['t'][i] < TSTOP:
              #             TSTOP = P['t'][i]
              #         break
      TSTOP = min(AllNegativeValues, key=AllNegativeValues.get)
      print(AllNegativeValues[TSTOP])
      P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
      T0 += TSPAN
      AllPoints.append(P)
#+END_SRC

#+RESULTS:
:RESULTS:
0 - 2f7330d7-ac38-4825-b25e-1cf0a59a9e12
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
AllNegativeValues
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[30]:
: {}
:END:

*** Define utility functions
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  def recomputeLowerBounds(model, PrevSteadyState, OriginalLB):
      all_exchanges = model_copy.exchanges
      for r in all_exchanges:
          model.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*PrevSteadyState[r.id]/(0.0005+PrevSteadyState[r.id])


  def get_ss(model):
      """
      Takes as input a PyDSTool Model object,
      Returns the SS values
      """
      Points=simulateModel(model)
      SSPoints={}
      for k in Points.keys():
          SSPoints[k]=Points[k][-1]
      return(SSPoints)

#+END_SRC
** Plot Results
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
T=[]
X=[]
for v in VarDef.keys():
        for P in AllPoints:
                if 'h2o' not in v :
                       # print(v)
                        T = P['t']
                        X = P[v]
                        plt.plot(T,X)
#                 T = P['t']
#                 X = P['X']
#                 plt.plot(T,X)

plt.xlabel('Time (minutes)')
plt.ylabel('gdw')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:
: Text(0,0.5,u'gdw')
[[file:./obipy-resources/2300s0Y.png]]
:END:
* Cleaned up version
** Headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
%matplotlib inline
import cobra
import PyDSTool as dst
import pandas as pd
import matplotlib.pyplot as plt
import copy
import sys
import pdb
import time
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[6]:
 :END:
 
** Utility Functions
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  # Functions for initialization
  def cleanupname(name):
      """
       The reaction names in the model files 
       don't have brackets or parentheses. I replaced
       those found in the mediaFluxes file.
       """
      # name = name.replace('[', '_LPAREN_')
      # name = name.replace(']', '_RPAREN_')
      # name = name.replace('(', '_LPAREN_')
      # name = name.replace(')', '_RPAREN_')

      name = name.replace('[', '__40__')
      name = name.replace(']', '__41__')
      name = name.replace('(', '__40__')
      name = name.replace(')', '__41__')


      # name = name.replace('[', '__91__')
      # name = name.replace(']', '__93__')
      # name = name.replace('(', '__91__')
      # name = name.replace(')', '__93__')
      return name

  def defineDFBAModel(SpeciesDict , MediaDF):
      print("Defining Dynamical model... \n")
      ParDef = dict()
      VarDef = dict()
      ICS = dict()
      exchange_list = []
      mediaDerivedComponents = {}
      for i, row in MediaDF.iterrows():
          N = cleanupname(row.Reaction)
          mediaDerivedComponents[N] = row['Flux Value'] / (24.0*60.0) # Per minute

      variable_dict = {
          # 'B_M':'B_MSource - (k_AD*B_M)/(k_3+B_M) - (k_AT*R_E*B_M)/(alpha_EM+R_E)-epsilon*B_M',
          # 'B':'max(0,epsilon*B_M-T) -k_5*P*B',
          'epsilon':'(epsilon_0-epsilon)/tau_p + f*P*(epsilon_max-epsilon)',
          'R_E':'(k_1*P)/(1+alpha_RE*I_E)-mu_RE*R_E +(1/(1+alpha_RE*I_E))',#*(a_1*B_M*T_I)/(gamma_1+B_M)',
          'I_E':'(k_IE*R_E)/(gamma_IE+R_E)-mu_IE*I_E', # +alpha_11*B_M',
          'P':'(k_PE*max(0,R_E-T_RE))/(1+gamma_PE*I_E)-mu_4*P ' # +(k_PM*B)/(gamma_12+B)

      }

      parameter_dict = {
          'B_MSource':2.2e6,#1.5e6,#
          'k_AD':1.5e6,#
          'k_3':6e6,
          'k_AT':0.03,
          'alpha_EM':0.18,
          'epsilon_0':0.1,
          'epsilon_max':0.21,
          'tau_p':24,
          'f':0.5,
          'a_1':0.1,#
          'gamma_1':5e6,
          'k_1':0.5,
          'alpha_RE':2,
          'mu_RE':0.1,
          'k_IE':50,#
          'gamma_IE':10,
          'alpha_11':0.1,
          'mu_IE':1,
          'T':1.1e6,
          'k_5':25,
          'k_PM':0.8,
          'gamma_12':1.2e6,
          'k_PE':0.002,
          'T_RE':0.65,
          'gamma_PE':1,
          'mu_4':0.05,
          'T_I':1e3 #????
      }
      #notebook
      initial_conditions = {
          #'B_M':1,
          'epsilon':0.1,
          'R_E':0,
          'I_E':0,
          #'B':1,
          'P':1
      }
      ParDef.update(parameter_dict)
      ICS.update(initial_conditions)
      VarDef.update(variable_dict)

      for species in SpeciesDict.keys():
          print("\nReading species " + str(species))
          SpeciesDict[species]['SpeciesModel'] = cobra.io.read_sbml_model(SpeciesDict[species]['File'])
          SpeciesDict[species]['OriginalLB'] = {r.id:r.lower_bound/10.0 for r in SpeciesDict[species]['SpeciesModel'].exchanges}
          # SpeciesDict[species]['OriginalLB'] = {r.id:r.lower_bound for r in SpeciesDict[species]['SpeciesModel'].exchanges}
          SpeciesDict[species]['solution'] = SpeciesDict[species]['SpeciesModel'].optimize()
          SpeciesDict[species]['Name'] = SpeciesDict[species]['SpeciesModel'].name.split(' ')[0] + '_' \
          + SpeciesDict[species]['SpeciesModel'].name.split(' ')[1].replace('.','')
          exchange_list += SpeciesDict[species]['SpeciesModel'].exchanges
          Name=SpeciesDict[species]['Name']

          ParDef['mu' + '_' + Name] = SpeciesDict[species]['solution'].objective_value/60
          VarDef[Name] =  'mu_' + Name + ' * ' + Name + ' - ' + 'Dilution * ' + Name + '- 0.2 *' + Name ### Biomass, 20% diffuse to mucosa
          # 10^12 is a placeholder for mass/cell
          VarDef[Name + '_M'] = '0.2* ' + Name +'*10^5 - (k_AD*' + Name + '_M)/(k_3+' + Name + '_M)'\
                                ' - (k_AT*R_E*' + Name + '_M)/(alpha_EM+R_E)-epsilon*' + Name + '_M'
          ICS[Name + '_M'] = 0.0 # This should be non zero

          VarDef[Name + '_BT'] = 'max(0,epsilon*' + Name + '_M - T_'+ Name + ') - k_5 * P *' + Name + '_BT'
          ICS[Name + '_BT'] = 0.0
          ParDef['T_' + Name] = 1.1e6

          VarDef['P'] += '+ k_PM *' + Name + '_BT / (gamma_12 +' + Name + '_BT )'
          VarDef['R_E'] += '* (a_1 * '+ Name + '_M * T_I/(gamma_1 + '+Name +'_M))'
          VarDef['I_E'] += ' + alpha_11 * ' + Name + '_M'
          ICS[Name] = SpeciesDict[species]['initAbundance']

      ParDef['Dilution'] = 0.002

      all_exchanges = set()

      for ex in exchange_list:
          all_exchanges.add(ex.id)

      for rid in all_exchanges:
          VarDef[rid] = '- Dilution * ' + rid
          ICS[rid] = 0.1 #10.0

          if rid in mediaDerivedComponents.keys():
              ParDef[rid + '_influx'] = mediaDerivedComponents[rid]
              VarDef[rid] += ' + ' +  rid + '_influx'

          for species in SpeciesDict.keys():
              if 'h2o' in rid: # Check to see if a unique metabolite is represented only once
                  print(species, rid)
              if rid in [species_r.id for species_r in SpeciesDict[species]['SpeciesModel'].exchanges]:
                  Name = SpeciesDict[species]['Name']
                  ParDef[rid + '_' + Name] = SpeciesDict[species]['solution'].fluxes[rid]/60.0
                  VarDef[rid] += ' + ' +  rid + '_' + Name + ' * ' + Name

      ModelDef = dst.args(name='Comunity',
                          pars=ParDef,
                          varspecs=VarDef,
                          ics=ICS)
      ModelDS = dst.Vode_ODEsystem(ModelDef)
      print("Done!")
      return (SpeciesDict, ModelDef, ModelDS)

  # Functions for model updates

  def recomputeLowerBounds(SpeciesDict, PrevSteadyState, Kmax):
      for species in SpeciesDict.keys():
          for rid in [rxn.id for rxn in SpeciesDict[species]['SpeciesModel'].exchanges]:
              SpeciesDict[species]['SpeciesModel'].reactions.get_by_id(rid) \
                                                     .lower_bound = \
                                                                    SpeciesDict[species]['OriginalLB'][rid] \
                                                                    ,* PrevSteadyState[rid]/(Kmax+PrevSteadyState[rid])
      return SpeciesDict

  def updateFluxParameters(SpeciesDict, ModelDS, PrevSteadyState):
      ParDef = {}
      ICS = {}
      for species in SpeciesDict:
          solution = SpeciesDict[species]['SpeciesModel'].optimize()
          Name = SpeciesDict[species]['Name']
          ParDef['mu_' + Name] = solution.objective_value/60.0
          ICS[Name] = PrevSteadyState[Name]
          exchanges = [r.id for r in SpeciesDict[species]['SpeciesModel'].exchanges]
          for rid in exchanges:
              # Control for cobra fl
              # Because very small non-zero solutions may come up despite 0 LB
              if abs(solution.fluxes[rid]/60.0) < 1e-12: 
                  solution.fluxes[rid] = 0
              ParDef[rid + '_' + Name] = solution.fluxes[rid]/60.0
              ICS[rid] = PrevSteadyState[rid]
      ModelDS.set(pars=ParDef, ics=ICS)
      return ModelDS

  def update(SpeciesDict, ModelDS, PrevSteadyState, Kmax):
      UpdatedSpeciesDict = recomputeLowerBounds(SpeciesDict,
                                                PrevSteadyState, Kmax)

      UpdatedDynamicModel = updateFluxParameters(UpdatedSpeciesDict,
                                                 ModelDS,
                                                 PrevSteadyState)
      return(UpdatedSpeciesDict, UpdatedDynamicModel)

  def get_ss(PointSet):
      SSPoints={}
      for k in PointSet.keys():
          SSPoints[k]=PointSet[k][-1]
      return(SSPoints)

  def checkNegativeMetabolites(PointSet, StoreNegatives):
      IndexStop = len(PointSet['t'])

      for variable in PointSet.keys():
          if any(PointSet[variable] < 0.0): # checking only final Tpoint, b/c monotonic
              varIndex = next((index for index,value in enumerate(PointSet[variable]) if value < 0), None)
              if varIndex < IndexStop:
                  # Update the index for the first negative crossing
                  IndexStop = varIndex

      if IndexStop < len(PointSet['t']) and IndexStop > 0:
          P_tilFirstNeg={}
          if len(PointSet[variable] > IndexStop+5):
              Extension = 5
          elif len(PointSet[variable] > IndexStop+2):
              Extension = 2
          else:
              Extension = 0
          for variable in PointSet.keys():
              P_tilFirstNeg[variable]=PointSet[variable][:IndexStop]
              if PointSet[variable][IndexStop + Extension] < 0.0:
                  P_tilFirstNeg[variable][IndexStop - 1] = 0
                  StoreNegatives.add(variable)
                  print('\t' + str(variable) +  'is 0 at ' + str( PointSet['t'][IndexStop]))

          P_tilFirstNeg['t'] = PointSet['t'][:IndexStop]
          PointSet = P_tilFirstNeg
      return(PointSet,StoreNegatives)

  def plotBiomass(SpeciesDict, AllPoints):
      TimePoints={}
      TimePoints['t'] =[]

      for P in AllPoints:
          TimePoints['t'] += list(P['t'])

      for sp in SpeciesDict.keys():
          Name = SpeciesDict[sp]['Name']
          TimePoints[Name] = []
          for P in AllPoints:
              TimePoints[Name]+=list(P[Name])

      for k in TimePoints.keys():
          if k != 't':
              plt.plot(TimePoints['t'], TimePoints[k], label = k)

          plt.xlabel('Time (minutes)')
      plt.ylabel('gdw')
      plt.legend(bbox_to_anchor=(1.2,1.2))


  def plotMetabolites(AllPoints):
      TimePoints={}
      TimePoints['t'] =[]

      for P in AllPoints:
          TimePoints['t'] += list(P['t'])

      for v in P.keys():
          TimePoints[v] = []
          for P in AllPoints:
              TimePoints[v]+=list(P[v])

      for k in TimePoints.keys():
          if k != 't':
              plt.plot(TimePoints['t'], TimePoints[v])

          plt.xlabel('Time (minutes)')
      plt.ylabel('mmol')
      plt.legend()

  def simulateCommunity(SpeciesDict, Diet, TEND=2000, MaxIter=200, Kmax=0.01):
      InitialValues = {}
      SpeciesDict, Definition, ModelDS = defineDFBAModel(SpeciesDict, Diet)
      InitialValues = {k:[v] for (k,v) in Definition.ics.iteritems()}
      AllPoints = []
      StoreNegatives = set()
      P = InitialValues
      T0= 0
      TSPAN = 60
      IndexStop = 1 
      i=0

      clockstart = time.clock()
      while T0 < TEND and i < MaxIter:
          i+=1
          print(str(i) + ' ' + str(T0))
          SpeciesDict, ModelDS = update(SpeciesDict, ModelDS, get_ss(P), Kmax)

          if T0+TSPAN > TEND:
              TSPAN = TEND - T0

          ModelDS.set(tdata=[T0, T0 + TSPAN])
          P = ModelDS.compute('test').sample() 
          OldT = P['t'][-1]
          # Initialize
          P, StoreNegatives = checkNegativeMetabolites(P, StoreNegatives) 
          T0 = P['t'][-1]
          if OldT != T0:
              TSPAN = 1.0
          else:
              TSPAN = 60
          AllPoints.append(P)

      print("This took " + str(time.clock() - clockstart) + "s")
      return(AllPoints, SpeciesDict, Definition)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[20]:
:END:

** Test:
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
    SpeciesDict = dict()

    SpeciesDict = {
        # 'Sp1': {'File': './data/average-european-diet/Bacteroides_sp_1_1_14.xml',
        #         'initAbundance': 0.01},
        # 'Sp2': {'File': './data/average-european-diet/Ruminococcus_flavefaciens_FD_1.xml',
        #         'initAbundance': 0.01},
        # 'Sp3': {'File': './data/average-european-diet/Lactobacillus_brevis_ATCC_367.xml',
        #         'initAbundance': 0.01},
        # 'Sp4': {'File': './data/average-european-diet/Mycobacterium_avium_subsp_avium_ATCC_25291.xml',
        #         'initAbundance': 0.01},
        # 'Sp5': {'File': './data/average-european-diet/Actinomyces_viscosus_C505.xml',
        #         'initAbundance': 0.01},
        # 'Sp6': {'File': './data/average-european-diet/Exiguobacterium_aurantiacum_DSM_6208.xml',
        #         'initAbundance': 0.01},
        # 'Sp7': {'File': './data/average-european-diet/Arcanobacterium_haemolyticum_DSM_20595.xml',
        #         'initAbundance': 0.01},
        # 'Sp8': {'File': './data/average-european-diet/Streptococcus_intermedius_JTH08.xml',
        #         'initAbundance': 0.01},
        # 'Sp9': {'File': './data/average-european-diet/Bifidobacterium_longum_infantis_ATCC_15697.xml',
        #         'initAbundance': 0.01},
        # 'Sp10': {'File': './data/average-european-diet/Desulfovibrio_piger_ATCC_29098.xml',
        #          'initAbundance': 0.01},
        'Sp11': {'File': './data/average-european-diet/Escherichia_coli_O157_H7_str_Sakai.xml',
                 'initAbundance': 0.01},

    } 

  # {
  #       # 'H': {'File':'../../Recon3D_301_SBML/Recon3D_301.xml',
  #       #         'initAbundance': 0.01},
  #       'Sp1': {'File':'./data/average-european-diet/Bacteroides_sp_1_1_14.xml',
  #               'initAbundance': 0.01},
  #       'Sp2': {'File':'./data/average-european-diet/Actinomyces_urogenitalis_DSM_15434.xml',
  #               'initAbundance': 0.01},
  #       'Sp3': {'File':'./data/average-european-diet/Bifidobacterium_longum_infantis_ATCC_15697.xml',
  #               'initAbundance': 0.01},
  #       'Sp4': {'File':'./data/average-european-diet/Desulfovibrio_piger_ATCC_29098.xml',
  #               'initAbundance': 0.01},
  #       'Sp5': {'File':'./data/average-european-diet/Exiguobacterium_aurantiacum_DSM_6208.xml',
  #               'initAbundance': 0.01},
  #       'Sp6': {'File':'./data/average-european-diet/Lactobacillus_brevis_ATCC_367.xml',
  #                  'initAbundance': 0.01},
  #       'Sp7': {'File':'./data/average-european-diet/Bacteroides_ovatus_ATCC_8483.xml',
  #       'initAbundance': 0.01},
  #       # 'Sp8': {'File':'./data/average-european-diet/Bacteroides_vulgatus_ATCC_8482.xml',
  #       # 'initAbundance': 0.01},
  #       # 'Sp9': {'File':'./data/average-european-diet/Bacteroides_fragilis_NCTC_9343.xml',
  #       # 'initAbundance': 0.01},
  #   }

    MediaDF = pd.read_csv('./data/diet-definitions/VMH_HighFiber.tsv', sep='\t')
    #MediaDF = pd.read_csv('./data/VMH_HighProtein.tsv', sep='\t')

    Output, SpecieDict, ModDefinition = simulateCommunity(SpeciesDict, MediaDF, MaxIter=10)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[29]:
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  for P in Output:
      plt.plot(P['t'], P['P'], 'g')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[34]:
[[file:./obipy-resources/29743bTu.png]]
:END:


#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t :ipyfile ./obipy-resources/2018-04-23-withECO157.png
plotBiomass(SpeciesDict, Output)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[7]:
[[file:./obipy-resources/2018-04-23-withECO157.png]]
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t :ipyfile ./obipy-resources/2018-04-23-withECO157-HighProt.png
plotBiomass(SpeciesDict, Output)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[11]:
[[file:./obipy-resources/2018-04-23-withECO157-HighProt.png]]
:END:

- 500 iterations took 136 s
- 300 iterations took 129s!
- 1000 iterations for 4 species simulated until 96 minutes took 255s
- 1000 iterations for 6 sp till 116 min took 335s
- 1000 iterations for 9 sp till 113min took 525s
- 2000 iterations for 9 sp till 85.7 min took 1021s

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
plotBiomass(SpeciesDict, Output)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[15]:
[[file:./obipy-resources/20398FEc.png]]
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
plotBiomass(SpeciesDict, Output)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[17]:
[[file:./obipy-resources/20398SOi.png]]
:END:


#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  for p in Output:
      plt.plot(p['t'],p['Escherichia_coli'])
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:
[[file:./obipy-resources/20398RbD.png]]
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  for P in Output:
      for k in P.keys():
          plt.plot(P['t'], P[k])
  plt.ylim([0,20])

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[42]:
: (0, 20)
[[file:./obipy-resources/20398ftE.png]]
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
Output[1].keys()
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[22]:
#+BEGIN_EXAMPLE
  ['Actinomyces_viscosus',
  'Arcanobacterium_haemolyticum',
  'Bacteroides_sp',
  'Bifidobacterium_longum',
  'DM_2HYMEPH',
  'DM_4HBA',
  'DM_5DRIB',
  'DM_5MTR',
  'DM_GCALD',
  'DM_clpn140__40__c__41__',
  'DM_clpn160__40__c__41__',
  'DM_clpn180__40__c__41__',
  'DM_clpni16__40__c__41__',
  'DM_dad_5',
  'DM_dhptd__40__c__41__',
  'DM_hcys_L__91__c__93__',
  'DM_pheme__40__c__41__',
  'DM_thmpp__40__c__41__',
  'Desulfovibrio_piger',
  'EX_12dgr180__40__e__41__',
  'EX_12ppd_S__40__e__41__',
  'EX_13ppd__40__e__41__',
  'EX_26dap_M__40__e__41__',
  'EX_2dmmq8__40__e__41__',
  'EX_2obut__40__e__41__',
  'EX_34dhphe__40__e__41__',
  'EX_3dhcdchol__40__e__41__',
  'EX_3dhchol__40__e__41__',
  'EX_3hcinnm__40__e__41__',
  'EX_3hpppn__40__e__41__',
  'EX_3mop__40__e__41__',
  'EX_4abut__40__e__41__',
  'EX_4abz__40__e__41__',
  'EX_4hbz__40__e__41__',
  'EX_5htrp__40__e__41__',
  'EX_7dhcdchol__40__e__41__',
  'EX_7ocholate__40__e__41__',
  'EX_C02528__40__e__41__',
  'EX_Lcyst__40__e__41__',
  'EX_Lkynr__91__e__93__',
  'EX_Ser_Thr__40__e__41__',
  'EX_T_antigen__40__e__41__',
  'EX_Tn_antigen__40__e__41__',
  'EX_Tyr_ggn__40__e__41__',
  'EX_ac__40__e__41__',
  'EX_acald__40__e__41__',
  'EX_acgal__40__e__41__',
  'EX_acgam__40__e__41__',
  'EX_acnam__40__e__41__',
  'EX_actn_R__40__e__41__',
  'EX_ade__40__e__41__',
  'EX_adn__40__e__41__',
  'EX_adpcbl__40__e__41__',
  'EX_ala_D__40__e__41__',
  'EX_ala_L__40__e__41__',
  'EX_alaasp__40__e__41__',
  'EX_alagln__40__e__41__',
  'EX_alaglu__40__e__41__',
  'EX_alagly__40__e__41__',
  'EX_alahis__40__e__41__',
  'EX_alaleu__40__e__41__',
  'EX_alathr__40__e__41__',
  'EX_alltn__40__e__41__',
  'EX_amp__40__e__41__',
  'EX_arab_L__40__e__41__',
  'EX_arabinogal__40__e__41__',
  'EX_arabttr__40__e__41__',
  'EX_arbt__40__e__41__',
  'EX_arg_L__40__e__41__',
  'EX_arsenb__40__e__41__',
  'EX_asn_L__40__e__41__',
  'EX_aso3__40__e__41__',
  'EX_aso4__40__e__41__',
  'EX_asp_L__40__e__41__',
  'EX_biomass__40__e__41__',
  'EX_btn__40__e__41__',
  'EX_butso3__40__e__41__',
  'EX_ca2__40__e__41__',
  'EX_cbl1__40__e__41__',
  'EX_cbl2__40__e__41__',
  'EX_cd2__40__e__41__',
  'EX_cellb__40__e__41__',
  'EX_cgly__40__e__41__',
  'EX_chol__40__e__41__',
  'EX_cholate__40__e__41__',
  'EX_chols__40__e__41__',
  'EX_chtbs__40__e__41__',
  'EX_cit__40__e__41__',
  'EX_cl__40__e__41__',
  'EX_co2__40__e__41__',
  'EX_cobalt2__40__e__41__',
  'EX_core2__40__e__41__',
  'EX_core3__40__e__41__',
  'EX_core4__40__e__41__',
  'EX_core5__40__e__41__',
  'EX_core6__40__e__41__',
  'EX_core7__40__e__41__',
  'EX_core8__40__e__41__',
  'EX_crn__40__e__41__',
  'EX_cro4__40__e__41__',
  'EX_csn__40__e__41__',
  'EX_ctbt__40__e__41__',
  'EX_cu2__40__e__41__',
  'EX_cys_L__40__e__41__',
  'EX_cytd__40__e__41__',
  'EX_dad_2__40__e__41__',
  'EX_dcyt__40__e__41__',
  'EX_ddca__40__e__41__',
  'EX_dextrin__40__e__41__',
  'EX_dgchol__40__e__41__',
  'EX_dgsn__40__e__41__',
  'EX_dhcinnm__40__e__41__',
  'EX_dhpppn__40__e__41__',
  'EX_din__40__e__41__',
  'EX_dopa__40__e__41__',
  'EX_drib__40__e__41__',
  'EX_dsT_antigen__40__e__41__',
  'EX_duri__40__e__41__',
  'EX_etha__40__e__41__',
  'EX_ethso3__40__e__41__',
  'EX_etoh__40__e__41__',
  'EX_f1a__40__e__41__',
  'EX_fe2__40__e__41__',
  'EX_fe3__40__e__41__',
  'EX_fol__40__e__41__',
  'EX_for__40__e__41__',
  'EX_fru__40__e__41__',
  'EX_fuc_L__40__e__41__',
  'EX_fum__40__e__41__',
  'EX_gal__40__e__41__',
  'EX_galt__40__e__41__',
  'EX_galur__40__e__41__',
  'EX_gam__40__e__41__',
  'EX_gbbtn__40__e__41__',
  'EX_gcald__40__e__41__',
  'EX_gchola__40__e__41__',
  'EX_glc_D__40__e__41__',
  'EX_glcn__40__e__41__',
  'EX_glcur__40__e__41__',
  'EX_gln_L__40__e__41__',
  'EX_glu_L__40__e__41__',
  'EX_gly__40__e__41__',
  'EX_glyasn__40__e__41__',
  'EX_glyasp__40__e__41__',
  'EX_glyb__40__e__41__',
  'EX_glyc3p__40__e__41__',
  'EX_glyc__40__e__41__',
  'EX_glycys__40__e__41__',
  'EX_glygln__40__e__41__',
  'EX_glyglu__40__e__41__',
  'EX_glygn2__40__e__41__',
  'EX_glygn4__40__e__41__',
  'EX_glygn5__40__e__41__',
  'EX_glyleu__40__e__41__',
  'EX_glymet__40__e__41__',
  'EX_glyphe__40__e__41__',
  'EX_glypro__40__e__41__',
  'EX_glytyr__40__e__41__',
  'EX_gncore1__40__e__41__',
  'EX_gncore2__40__e__41__',
  'EX_gsn__40__e__41__',
  'EX_gthrd__40__e__41__',
  'EX_gua__40__e__41__',
  'EX_h2__40__e__41__',
  'EX_h2o__40__e__41__',
  'EX_h2s__40__e__41__',
  'EX_h__40__e__41__',
  'EX_hdca__40__e__41__',
  'EX_hexs__40__e__41__',
  'EX_hg2__40__e__41__',
  'EX_his_L__40__e__41__',
  'EX_hista__40__e__41__',
  'EX_hxan__40__e__41__',
  'EX_ile_L__40__e__41__',
  'EX_indole__40__e__41__',
  'EX_inost__40__e__41__',
  'EX_ins__40__e__41__',
  'EX_inulin__40__e__41__',
  'EX_isetac__40__e__41__',
  'EX_isobut__40__e__41__',
  'EX_isocapr__40__e__41__',
  'EX_isoval__40__e__41__',
  'EX_k__40__e__41__',
  'EX_kesto__40__e__41__',
  'EX_kestopt__40__e__41__',
  'EX_kestottr__40__e__41__',
  'EX_lac_D__40__e__41__',
  'EX_lac_L__40__e__41__',
  'EX_lcts__40__e__41__',
  'EX_leu_L__40__e__41__',
  'EX_lys_L__40__e__41__',
  'EX_malt__40__e__41__',
  'EX_malthx__40__e__41__',
  'EX_malttr__40__e__41__',
  'EX_man__40__e__41__',
  'EX_mantr__40__e__41__',
  'EX_melib__40__e__41__',
  'EX_meoh__40__e__41__',
  'EX_met_D__40__e__41__',
  'EX_met_L__40__e__41__',
  'EX_metala__40__e__41__',
  'EX_metsox_R_L__40__e__41__',
  'EX_metsox_S_L__40__e__41__',
  'EX_mg2__40__e__41__',
  'EX_mn2__40__e__41__',
  'EX_mnl__40__e__41__',
  'EX_mops__40__e__41__',
  'EX_mqn7__40__e__41__',
  'EX_mqn8__40__e__41__',
  'EX_mso3__40__e__41__',
  'EX_na1__40__e__41__',
  'EX_nac__40__e__41__',
  'EX_ncam__40__e__41__',
  'EX_nh4__40__e__41__',
  'EX_ni2__40__e__41__',
  'EX_nmn__40__e__41__',
  'EX_no2__40__e__41__',
  'EX_no3__40__e__41__',
  'EX_o2__40__e__41__',
  'EX_ocdca__40__e__41__',
  'EX_orn__40__e__41__',
  'EX_oxa__40__e__41__',
  'EX_pb__40__e__41__',
  'EX_pect__40__e__41__',
  'EX_phe_L__40__e__41__',
  'EX_pheme__40__e__41__',
  'EX_pi__40__e__41__',
  'EX_pnto_R__40__e__41__',
  'EX_ppa__40__e__41__',
  'EX_ppi__40__e__41__',
  'EX_pppn__40__e__41__',
  'EX_pro_L__40__e__41__',
  'EX_ptrc__40__e__41__',
  'EX_pullulan1200__40__e__41__',
  'EX_pydam__40__e__41__',
  'EX_pydx__40__e__41__',
  'EX_pydxn__40__e__41__',
  'EX_pyr__40__e__41__',
  'EX_q8__40__e__41__',
  'EX_raffin__40__e__41__',
  'EX_rib_D__40__e__41__',
  'EX_ribflv__40__e__41__',
  'EX_rmn__40__e__41__',
  'EX_sT_antigen__40__e__41__',
  'EX_sTn_antigen__40__e__41__',
  'EX_salcn__40__e__41__',
  'EX_sbt_D__40__e__41__',
  'EX_ser_D__40__e__41__',
  'EX_ser_L__40__e__41__',
  'EX_sheme__40__e__41__',
  'EX_so3__40__e__41__',
  'EX_so4__40__e__41__',
  'EX_spmd__40__e__41__',
  'EX_srtn__40__e__41__',
  'EX_strch1__40__e__41__',
  'EX_strch2__40__e__41__',
  'EX_stys__40__e__41__',
  'EX_succ__40__e__41__',
  'EX_sucr__40__e__41__',
  'EX_sulfac__40__e__41__',
  'EX_taur__40__e__41__',
  'EX_tchola__40__e__41__',
  'EX_tdchola__40__e__41__',
  'EX_thm__40__e__41__',
  'EX_thr_L__40__e__41__',
  'EX_thymd__40__e__41__',
  'EX_tma__40__e__41__',
  'EX_tre__40__e__41__',
  'EX_trp_L__40__e__41__',
  'EX_trypta__40__e__41__',
  'EX_tsul__40__e__41__',
  'EX_ttdca__40__e__41__',
  'EX_tym__40__e__41__',
  'EX_tyr_L__40__e__41__',
  'EX_ura__40__e__41__',
  'EX_urea__40__e__41__',
  'EX_uri__40__e__41__',
  'EX_val_L__40__e__41__',
  'EX_xan__40__e__41__',
  'EX_xyl_D__40__e__41__',
  'EX_zn2__40__e__41__',
  'Exiguobacterium_aurantiacum',
  'Lactobacillus_brevis',
  'Mycobacterium_avium',
  'Ruminococcus_flavefaciens',
  'Streptococcus_intermedius',
  'dreplication',
  'pbiosynthesis',
  'rtranscription',
  'sink_PGPm1__91__c__93__',
  'sink_dmbzid',
  'sink_gthrd__40__c__41__']
#+END_EXAMPLE
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t

A ={'b':2}
B = {'a':1}
B.update(A)
B
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
: {'a': 1, 'b': 2}
:END:
