* Legacy                                                           :noexport:
** Defining Dynamic FBA model for a single species
*** Import headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 %matplotlib inline
 import cobra
 import PyDSTool as dst
 import pandas as pd
 import matplotlib.pyplot as plt
 import copy
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[1]:
 :END:
*** File Paths for Media spec and FBA model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer 
 model = cobra.io.read_sbml_model('./data/Bacteroides_sp_1_1_14.xml')
 mediaFluxes = pd.read_csv('./data/VMH_HighFiber.tsv', sep='\t')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[3]:
 :END:
*** Extract exchange reactions into variable definition and ics dictionary
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   def cleanupname(name):
       """
       The reaction names in the model files 
       don't have brackets or parentheses. I replaced
       those found in the mediaFluxes file.
       """
       name = name.replace('[', '_LPAREN_')
       name = name.replace(']', '_RPAREN_')
       name = name.replace('(', '_LPAREN_')
       name = name.replace(')', '_RPAREN_')
       return name

   """
   Initialize dictionaries for defining the ODE variables for a 
   single species
   """
   VarDef = dict()
   ParDef_base = dict()
   ICS_base = dict()

   solution = model.optimize() # Get fluxes
   all_exchanges = model.exchanges
   media_derived_components = dict()

   exchange_reaction_ids = [rxn.id for rxn in all_exchanges]
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[4]:
 :END:

**** Extract the reaction names and flux values into a dictionary.
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 for i, row in mediaFluxes.iterrows():
     N = cleanupname(row.Reaction)
     if N in exchange_reaction_ids:
         media_derived_components[N] = row['Flux Value'] / (24.0*60.0) # Per minute

 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[51]:
 :END:

**** Get the outfluxes
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 out_fluxes = []
 for k in all_exchanges:
     if k.reversibility and k.id not in media_derived_components.keys():
         out_fluxes.append(k.id)

 ParDef_base['mu'] = solution.objective_value/60.0
 VarDef['X'] =  'mu * X'
 ICS_base['X'] = 1e-1
 for r in all_exchanges:
     if r.id in media_derived_components.keys():
         ParDef_base[r.id + '_influx'] = media_derived_components[r.id]
         ParDef_base[r.id + '_consumption'] = solution.fluxes[r.id]
         ICS_base[r.id] = media_derived_components[r.id]
         VarDef[r.id] = r.id + '_influx + ' + r.id + '_consumption' + ' * X'
     if r.id in out_fluxes:
         ParDef_base[r.id + '_outflux'] = solution.fluxes[r.id] 
         VarDef[r.id] = r.id + '_outflux * X'
         ICS_base[r.id] = 0.0
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[52]:
 :END:

*** Define PyDSTool Model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
   TSPAN = 5

   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   def simulateModel(ModelDS, ParDef, ICS, TSPAN, tstart):
       ModelDS.set(ics=ICS ,pars=ParDef,tdata=[tstart, tstart + TSPAN])
       P = ModelDS.compute('test').sample(dt=0.1)
       return(P)
   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   ModelDef =dst.args(name='Bacteroides',
                     varspecs=VarDef,
                     pars=ParDef,
                     ics=ICS,
                     )

   ModelDS = dst.Vode_ODEsystem(ModelDef)

   P = simulateModel(ModelDS, ParDef, ICS,TSPAN, 0.0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[53]:
 :END:

*** Create Upperlimit
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   AllPoints = []
   AllPoints.append(P)
   OriginalLB = {}
   model_copy = copy.deepcopy(model)
   T0=TSPAN

   for r in model_copy.reactions:
       if r in model_copy.exchanges:
           OriginalLB[r.id] = r.lower_bound

   for i in range(0, 10):
       print(T0)
       solution = model_copy.optimize()
       all_exchanges = model_copy.exchanges
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
               model_copy.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*P[r.id][-1]/(0.0005+P[r.id][-1])
               if r.id == 'EX_glu_L_LPAREN_e_RPAREN_':
                   print(r.id + ': ' +str(OriginalLB[r.id]) + ' -> ' + str(model_copy.reactions.get_by_id(r.id).lower_bound))
       solution = model_copy.optimize()
    #   print('mu= ' +str(solution.objective_value))
       ParDef['mu'] = solution.objective_value/60.0
       ICS['X'] = P['X'][-1]
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
                  if P[r.id][-1] < 0.0:
                      ICS[r.id] = 0.0
                  else:
    
                      ParDef[r.id + '_influx'] = media_derived_components[r.id]
                      ParDef[r.id + '_consumption'] = solution.fluxes[r.id]
                      ICS[r.id] = P[r.id][-1]
           if r.id in out_fluxes:
               ParDef[r.id + '_outflux'] = solution.fluxes[r.id] 
               ICS[r.id] = P[r.id][-1] # 0.0
       del P
       P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
   #    print('EX_glu_L_LPAREN_e_RPAREN_' + str(P['EX_glu_L_LPAREN_e_RPAREN_'][-1]))
       T0 += TSPAN

       AllPoints.append(P)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[54]:
 :END:



*** Results
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/metabolite-traj-1e-3.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:
                   if 'h2o' not in v :
                           T = P['t']
                           X = P[v]
                           plt.plot(T,X)
                   # T = P['t']
                   # X = P['X']
                   # plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('mmol')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[55]:
 : Text(0,0.5,u'mmol')
 [[file:./obipy-resources/metabolite-traj-1e-3.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/biomass-1e-1.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:

                   T = P['t']
                   X = P['X']
                   plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('gdw')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[56]:
 : Text(0,0.5,u'gdw')
 [[file:./obipy-resources/biomass-1e-1.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
 len(VarDef.keys())
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[10]:
 : 59
 :END:
** Defining Dynamic FBA model for multiple species
 <2018-04-12 Thu>
*** Import headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 %matplotlib inline
 import cobra
 import PyDSTool as dst
 import pandas as pd
 import matplotlib.pyplot as plt
 import copy
 import sys
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[40]:
 :END:
*** File Paths for Media spec and FBA model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer 
 PATH = '/home/cerevisaj/Documents/VT/Problem-Solving/problem-solving-2018/dfba'
 model = cobra.io.read_sbml_model(PATH + '/data/Bacteroides_sp_1_1_14.xml')
 mediaFluxes = pd.read_csv(PATH + '/data/VMH_HighFiber.tsv', sep='\t')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[44]:
 :END:
*** Extract exchange reactions into variable definition and ics dictionary
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   def cleanupname(name):
       """
       The reaction names in the model files 
       don't have brackets or parentheses. I replaced
       those found in the mediaFluxes file.
       """
       name = name.replace('[', '_LPAREN_')
       name = name.replace(']', '_RPAREN_')
       name = name.replace('(', '_LPAREN_')
       name = name.replace(')', '_RPAREN_')
       return name

   """
   Initialize dictionaries for defining the ODE variables for a 
   single species
   """
   VarDef = dict()
   ParDef_base = dict()
   ICS_base = dict()

   solution = model.optimize() # Get fluxes
   all_exchanges = model.exchanges
   media_derived_components = dict()

   exchange_reaction_ids = [rxn.id for rxn in all_exchanges]
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[50]:
 :END:

**** Extract the reaction names and flux values into a dictionary.
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 for i, row in mediaFluxes.iterrows():
     N = cleanupname(row.Reaction)
     if N in exchange_reaction_ids:
         media_derived_components[N] = row['Flux Value'] / (24.0*60.0) # Per minute

 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[51]:
 :END:

**** Get the outfluxes
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
 out_fluxes = []
 for k in all_exchanges:
     if k.reversibility and k.id not in media_derived_components.keys():
         out_fluxes.append(k.id)

 ParDef_base['mu'] = solution.objective_value/60.0
 VarDef['X'] =  'mu * X'
 ICS_base['X'] = 1e-1
 for r in all_exchanges:
     if r.id in media_derived_components.keys():
         ParDef_base[r.id + '_influx'] = media_derived_components[r.id]
         ParDef_base[r.id + '_consumption'] = solution.fluxes[r.id]
         ICS_base[r.id] = media_derived_components[r.id]
         VarDef[r.id] = r.id + '_influx + ' + r.id + '_consumption' + ' * X'
     if r.id in out_fluxes:
         ParDef_base[r.id + '_outflux'] = solution.fluxes[r.id] 
         VarDef[r.id] = r.id + '_outflux * X'
         ICS_base[r.id] = 0.0
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[52]:
 :END:

*** Define PyDSTool Model
 #+BEGIN_SRC ipython :session :exports both :results raw drawer
   TSPAN = 5

   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   def simulateModel(ModelDS, ParDef, ICS, TSPAN, tstart):
       ModelDS.set(ics=ICS ,pars=ParDef,tdata=[tstart, tstart + TSPAN])
       P = ModelDS.compute('test').sample(dt=0.1)
       return(P)
   ParDef = copy.deepcopy(ParDef_base)
   ICS = copy.deepcopy(ICS_base)
   ModelDef =dst.args(name='Bacteroides',
                     varspecs=VarDef,
                     pars=ParDef,
                     ics=ICS,
                     )

   ModelDS = dst.Vode_ODEsystem(ModelDef)

   P = simulateModel(ModelDS, ParDef, ICS,TSPAN, 0.0)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[53]:
 :END:

*** Create Upperlimit
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
   AllPoints = []
   AllPoints.append(P)
   OriginalLB = {}
   model_copy = copy.deepcopy(model)
   T0=TSPAN

   for r in model_copy.reactions:
       if r in model_copy.exchanges:
           OriginalLB[r.id] = r.lower_bound

   for i in range(0, 10):
       print(T0)
       solution = model_copy.optimize()
       all_exchanges = model_copy.exchanges
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
               model_copy.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*P[r.id][-1]/(0.0005+P[r.id][-1])
               if r.id == 'EX_glu_L_LPAREN_e_RPAREN_':
                   print(r.id + ': ' +str(OriginalLB[r.id]) + ' -> ' + str(model_copy.reactions.get_by_id(r.id).lower_bound))
       solution = model_copy.optimize()
    #   print('mu= ' +str(solution.objective_value))
       ParDef['mu'] = solution.objective_value/60.0
       ICS['X'] = P['X'][-1]
       for r in all_exchanges:
           if r.id in media_derived_components.keys():
                  if P[r.id][-1] < 0.0:
                      ICS[r.id] = 0.0
                  else:
    
                      ParDef[r.id + '_influx'] = media_derived_components[r.id]
                      ParDef[r.id + '_consumption'] = solution.fluxes[r.id]
                      ICS[r.id] = P[r.id][-1]
           if r.id in out_fluxes:
               ParDef[r.id + '_outflux'] = solution.fluxes[r.id] 
               ICS[r.id] = P[r.id][-1] # 0.0
       del P
       P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
   #    print('EX_glu_L_LPAREN_e_RPAREN_' + str(P['EX_glu_L_LPAREN_e_RPAREN_'][-1]))
       T0 += TSPAN

       AllPoints.append(P)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[54]:
 :END:



*** Results
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/metabolite-traj-1e-3.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:
                   if 'h2o' not in v :
                           T = P['t']
                           X = P[v]
                           plt.plot(T,X)
                   # T = P['t']
                   # X = P['X']
                   # plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('mmol')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[55]:
 : Text(0,0.5,u'mmol')
 [[file:./obipy-resources/metabolite-traj-1e-3.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :ipyfile ./obipy-resources/biomass-1e-1.png
    T=[]
    X=[]
   for v in VarDef.keys():
           for P in AllPoints:

                   T = P['t']
                   X = P['X']
                   plt.plot(T,X)

   plt.xlabel('Time (minutes)')
   plt.ylabel('gdw')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[56]:
 : Text(0,0.5,u'gdw')
 [[file:./obipy-resources/biomass-1e-1.png]]
 :END:

 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
 len(VarDef.keys())
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[10]:
 : 59
 :END:
* Current
* Final Definition of Single Species model
** Headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
%matplotlib inline
import cobra
import PyDSTool as dst
import pandas as pd
import matplotlib.pyplot as plt
import copy
import sys
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[1]:
 :END:

** Paths to data
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
model = cobra.io.read_sbml_model('./data/Bacteroides_sp_1_1_14.xml')
mediaFluxes = pd.read_csv('./data/VMH_HighFiber.tsv', sep='\t')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[2]:
:END:

** Read file
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
def cleanupname(name):
    """
    The reaction names in the model files 
    don't have brackets or parentheses. I replaced
    those found in the mediaFluxes file.
    """
    name = name.replace('[', '_LPAREN_')
    name = name.replace(']', '_RPAREN_')
    name = name.replace('(', '_LPAREN_')
    name = name.replace(')', '_RPAREN_')
    return name

"""
Initialize dictionaries for defining the ODE variables for a 
single species
"""

VarDef = dict()
ParDef_base = dict()
ICS_base = dict()

solution = model.optimize() # Get fluxes
all_exchanges = model.exchanges
media_derived_components = dict()

exchange_reaction_ids = [rxn.id for rxn in all_exchanges]
#+END_SRC

** Extract reactions+names
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
for i, row in mediaFluxes.iterrows():
    N = cleanupname(row.Reaction)
    if N in exchange_reaction_ids:
        media_derived_components[N] = row['Flux Value'] / (24.0*60.0) # Per minute
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[12]:
:END:

** Simulate
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t

ParDef_base['mu'] = solution.objective_value/60.0
VarDef['X'] =  'mu * X'
ICS_base['X'] = 1e-1

for r in all_exchanges:
    ParDef_base[r.id + '_Bact'] = solution.fluxes[r.id]
    if r.id in media_derived_components.keys():
        ParDef_base[r.id + '_influx'] = media_derived_components[r.id]
        VarDef[r.id] = r.id + '_influx +' + r.id + '_Bact' + ' * X'
    else: 
        VarDef[r.id] =  r.id + '_Bact' + ' * X'
    ICS_base[r.id] = 1

#+END_SRC

#+RESULTS:
:RESULTS:
# Out[14]:
:END:

** Define Dynamical model
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
TSPAN = 5

ParDef = copy.deepcopy(ParDef_base)
ICS = copy.deepcopy(ICS_base)
def simulateModel(ModelDS, ParDef, ICS, TSPAN, tstart):
    ModelDS.set(ics=ICS ,pars=ParDef,tdata=[tstart, tstart + TSPAN])
    P = ModelDS.compute('test').sample(dt=0.1)
    return(P)
ParDef = copy.deepcopy(ParDef_base)
ICS = copy.deepcopy(ICS_base)
ModelDef =dst.args(name='Bacteroides',
                  varspecs=VarDef,
                  pars=ParDef,
                  ics=ICS,
                  )

ModelDS = dst.Vode_ODEsystem(ModelDef)
P= {}
for k in ICS_base.keys():
    P[k] = [ICS_base[k]]
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[15]:
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  AllPoints = []

  OriginalLB = {}
  model_copy = copy.deepcopy(model)
  T0=0

  for r in model_copy.reactions:
      if r in model_copy.exchanges:
          OriginalLB[r.id] = r.lower_bound

  for i in range(0, 2):
      print(T0)
      all_exchanges = model_copy.exchanges
      for r in all_exchanges:
          model_copy.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*P[r.id][-1]/(0.0005+P[r.id][-1])

          # if r.id == 'EX_adn_L_LPAREN_e_RPAREN_':
          #     print(r.id + ': ' +str(OriginalLB[r.id]) + ' -> ' + str(model_copy.reactions.get_by_id(r.id).lower_bound))
      solution = model_copy.optimize()
      ParDef['mu'] = solution.objective_value/60.0
      ICS['X'] = P['X'][-1]
      for r in all_exchanges:
          ParDef_base[r.id + '_Bact'] = solution.fluxes[r.id]
          ICS[r.id] = P[r.id][-1]
      P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
      TSTOP = T0+TSPAN
      AllNegativeValues = {}
      for variable in VarDef.keys():

          if P[variable][-1] < 0.0:
              AllNegativeValues = {key:P['t'][P[variable].index(value)] for value in P[variable] if P[variable] < 0.0 }
              # for p in P[variable]:
              #     if p < 0.0:
              #         AllNegativeValues[variable] = P['t'][index]
              #         break
              #     index += 1
              # for i in range(0, len(P[variable])):
              #     if P[variable][i] < 0.0:
              #         if P['t'][i] < TSTOP:
              #             TSTOP = P['t'][i]
              #         break
      TSTOP = min(AllNegativeValues, key=AllNegativeValues.get)
      print(AllNegativeValues[TSTOP])
      P = simulateModel(ModelDS, ParDef, ICS,TSPAN, T0)
      T0 += TSPAN
      AllPoints.append(P)
#+END_SRC

#+RESULTS:
:RESULTS:
0 - 2f7330d7-ac38-4825-b25e-1cf0a59a9e12
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
AllNegativeValues
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[30]:
: {}
:END:

*** Define utility functions
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  def recomputeLowerBounds(model, PrevSteadyState, OriginalLB):
      all_exchanges = model_copy.exchanges
      for r in all_exchanges:
          model.reactions.get_by_id(r.id).lower_bound = OriginalLB[r.id]*PrevSteadyState[r.id]/(0.0005+PrevSteadyState[r.id])


  def get_ss(model):
      """
      Takes as input a PyDSTool Model object,
      Returns the SS values
      """
      Points=simulateModel(model)
      SSPoints={}
      for k in Points.keys():
          SSPoints[k]=Points[k][-1]
      return(SSPoints)

#+END_SRC
** Plot Results
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
T=[]
X=[]
for v in VarDef.keys():
        for P in AllPoints:
                if 'h2o' not in v :
                       # print(v)
                        T = P['t']
                        X = P[v]
                        plt.plot(T,X)
#                 T = P['t']
#                 X = P['X']
#                 plt.plot(T,X)

plt.xlabel('Time (minutes)')
plt.ylabel('gdw')
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[8]:
: Text(0,0.5,u'gdw')
[[file:./obipy-resources/2300s0Y.png]]
:END:
* Cleaned up version
** Headers
 #+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
%matplotlib inline
import cobra
import PyDSTool as dst
import pandas as pd
import matplotlib.pyplot as plt
import copy
import sys
import pdb
import time
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 # Out[1]:
 :END:
 
** Utility Functions
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
  # Functions for initialization
  def cleanupname(name):
      """
       The reaction names in the model files 
       don't have brackets or parentheses. I replaced
       those found in the mediaFluxes file.
       """
      # name = name.replace('[', '_LPAREN_')
      # name = name.replace(']', '_RPAREN_')
      # name = name.replace('(', '_LPAREN_')
      # name = name.replace(')', '_RPAREN_')

      name = name.replace('[', '__40__')
      name = name.replace(']', '__41__')
      name = name.replace('(', '__40__')
      name = name.replace(')', '__41__')


      # name = name.replace('[', '__91__')
      # name = name.replace(']', '__93__')
      # name = name.replace('(', '__91__')
      # name = name.replace(')', '__93__')
      return name

  def defineDFBAModel(SpeciesDict , MediaDF):
      print("Defining Dynamical model... \n")
      ParDef = dict()
      VarDef = dict()
      ICS = dict()
      exchange_list = []
      mediaDerivedComponents = {}
      for i, row in MediaDF.iterrows():
          N = cleanupname(row.Reaction)
          mediaDerivedComponents[N] = row['Flux Value'] / (24.0*60.0) # Per minute

      for species in SpeciesDict.keys():
          print("\nReading species " + str(species))
          SpeciesDict[species]['SpeciesModel'] = cobra.io.read_sbml_model(SpeciesDict[species]['File'])
          SpeciesDict[species]['OriginalLB'] = {r.id:r.lower_bound/10.0 for r in SpeciesDict[species]['SpeciesModel'].exchanges}
          # SpeciesDict[species]['OriginalLB'] = {r.id:r.lower_bound for r in SpeciesDict[species]['SpeciesModel'].exchanges}
          SpeciesDict[species]['solution'] = SpeciesDict[species]['SpeciesModel'].optimize()
          SpeciesDict[species]['Name'] = SpeciesDict[species]['SpeciesModel'].name.split(' ')[0] + '_' \
          + SpeciesDict[species]['SpeciesModel'].name.split(' ')[1].replace('.','')
          exchange_list += SpeciesDict[species]['SpeciesModel'].exchanges
          Name=SpeciesDict[species]['Name']
          ParDef['mu' + '_' + Name] = SpeciesDict[species]['solution'].objective_value/60
          VarDef[Name] =  'mu_' + Name + ' * ' + Name + ' - ' + 'Dilution * ' + Name ### Biomass
          ICS[Name] = SpeciesDict[species]['initAbundance']

      ParDef['Dilution'] = 0.002

      all_exchanges = set()

      for ex in exchange_list:
          all_exchanges.add(ex.id)

      for rid in all_exchanges:
          VarDef[rid] = '- Dilution * ' + rid
          ICS[rid] = 0.1 #10.0

          if rid in mediaDerivedComponents.keys():
              ParDef[rid + '_influx'] = mediaDerivedComponents[rid]
              VarDef[rid] += ' + ' +  rid + '_influx'

          for species in SpeciesDict.keys():
              if 'h2o' in rid: # Check to see if a unique metabolite is represented only once
                  print(species, rid)
              if rid in [species_r.id for species_r in SpeciesDict[species]['SpeciesModel'].exchanges]:
                  Name = SpeciesDict[species]['Name']
                  ParDef[rid + '_' + Name] = SpeciesDict[species]['solution'].fluxes[rid]/60.0
                  VarDef[rid] += ' + ' +  rid + '_' + Name + ' * ' + Name

      ModelDef = dst.args(name='Comunity',
                          pars=ParDef,
                          varspecs=VarDef,
                          ics=ICS)
      ModelDS = dst.Vode_ODEsystem(ModelDef)
      print("Done!")
      return (SpeciesDict, ModelDef, ModelDS)

  # Functions for model updates

  def recomputeLowerBounds(SpeciesDict, PrevSteadyState, Kmax):
      for species in SpeciesDict.keys():
          for rid in [rxn.id for rxn in SpeciesDict[species]['SpeciesModel'].exchanges]:
              SpeciesDict[species]['SpeciesModel'].reactions.get_by_id(rid) \
                                                     .lower_bound = \
                                                                    SpeciesDict[species]['OriginalLB'][rid] \
                                                                    ,* PrevSteadyState[rid]/(Kmax+PrevSteadyState[rid])
              # if abs(SpeciesDict[species]['SpeciesModel'].reactions.get_by_id(rid).lower_bound) < 1e-10:
              #     # s = numpy.sign(SpeciesDict[species]['SpeciesModel'].reactions.get_by_id(rid).lower_bound)
              #     SpeciesDict[species]['SpeciesModel'].reactions.get_by_id(rid).lower_bound = 0.0
      return SpeciesDict

  def updateFluxParameters(SpeciesDict, ModelDS, PrevSteadyState):
      ParDef = {}
      ICS = {}
      for species in SpeciesDict:
          solution = SpeciesDict[species]['SpeciesModel'].optimize()
          Name = SpeciesDict[species]['Name']
          ParDef['mu_' + Name] = solution.objective_value/60.0
          ICS[Name] = PrevSteadyState[Name]
          exchanges = [r.id for r in SpeciesDict[species]['SpeciesModel'].exchanges]
          for rid in exchanges:
              if abs(solution.fluxes[rid]/60.0) < 1e-12: # Because very small non-zero solutions may come up despite 0 LB
                  solution.fluxes[rid] = 0
              ParDef[rid + '_' + Name] = solution.fluxes[rid]/60.0
              ICS[rid] = PrevSteadyState[rid]
      ModelDS.set(pars=ParDef, ics=ICS)
      return ModelDS

  def update(SpeciesDict, ModelDS, PrevSteadyState, Kmax):
      UpdatedSpeciesDict = recomputeLowerBounds(SpeciesDict,
                                                PrevSteadyState, Kmax)

      UpdatedDynamicModel = updateFluxParameters(UpdatedSpeciesDict,
                                                 ModelDS,
                                                 PrevSteadyState)
      return(UpdatedSpeciesDict, UpdatedDynamicModel)

  def get_ss(PointSet):
      SSPoints={}
      for k in PointSet.keys():
          SSPoints[k]=PointSet[k][-1]
      return(SSPoints)

  def checkNegativeMetabolites(PointSet, StoreNegatives):
      IndexStop = len(PointSet['t'])

      for variable in PointSet.keys():
          if any(PointSet[variable] < 0.0): # checking only final Tpoint, b/c monotonic
              varIndex = next((index for index,value in enumerate(PointSet[variable]) if value < 0), None)
              if varIndex < IndexStop:
                  # Update the index for the first negative crossing
                  IndexStop = varIndex

      if IndexStop < len(PointSet['t']) and IndexStop > 0:
          P_tilFirstNeg={}
          if len(PointSet[variable] > IndexStop+5):
              Extension = 5
          elif len(PointSet[variable] > IndexStop+2):
              Extension = 2
          else:
              Extension = 0
          for variable in PointSet.keys():
              P_tilFirstNeg[variable]=PointSet[variable][:IndexStop]
              if PointSet[variable][IndexStop + Extension] < 0.0:
                  P_tilFirstNeg[variable][IndexStop - 1] = 0
                  StoreNegatives.add(variable)
                  print('\t' + str(variable) +  'is 0 at ' + str( PointSet['t'][IndexStop]))

          P_tilFirstNeg['t'] = PointSet['t'][:IndexStop]
          PointSet = P_tilFirstNeg
      return(PointSet,StoreNegatives)

  def plotBiomass(SpeciesDict, AllPoints):
      TimePoints={}
      TimePoints['t'] =[]

      for P in AllPoints:
          TimePoints['t'] += list(P['t'])

      for sp in SpeciesDict.keys():
          Name = SpeciesDict[sp]['Name']
          TimePoints[Name] = []
          for P in AllPoints:
              TimePoints[Name]+=list(P[Name])

      for k in TimePoints.keys():
          if k != 't':
              plt.plot(TimePoints['t'], TimePoints[k], label = k)

          plt.xlabel('Time (minutes)')
      plt.ylabel('gdw')
      plt.legend()


  def plotMetabolites(AllPoints):
      TimePoints={}
      TimePoints['t'] =[]

      for P in AllPoints:
          TimePoints['t'] += list(P['t'])

      for v in P.keys():
          TimePoints[v] = []
          for P in AllPoints:
              TimePoints[v]+=list(P[v])

      for k in TimePoints.keys():
          if k != 't':
              plt.plot(TimePoints['t'], TimePoints[v])

          plt.xlabel('Time (minutes)')
      plt.ylabel('mmol')
      plt.legend()

  def simulateCommunity(SpeciesDict, Diet):
      InitialValues = {}
      SpeciesDict, Definition, ModelDS = defineDFBAModel(SpeciesDict, Diet)
      InitialValues = {k:[v] for (k,v) in Definition.ics.iteritems()}
      AllPoints = []
      StoreNegatives = set()
      P = InitialValues
      MaxIter= 300
      T0= 0
      TEND = 2000
      TSPAN = 60
      Kmax = 0.01#0.01
      IndexStop = 1 
      i=0

      clockstart = time.clock()
      while T0 < TEND and i < MaxIter:
          i+=1
          print(str(i) + ' ' + str(T0))
          SpeciesDict, ModelDS = update(SpeciesDict, ModelDS, get_ss(P), Kmax)

          if T0+TSPAN > TEND:
              TSPAN = TEND - T0

          ModelDS.set(tdata=[T0, T0 + TSPAN])
          P = ModelDS.compute('test').sample() 
          OldT = P['t'][-1]
          # Initialize
          P, StoreNegatives = checkNegativeMetabolites(P, StoreNegatives) 
          T0 = P['t'][-1]
          if OldT != T0:
              TSPAN = 1.0
          else:
              TSPAN = 60
          AllPoints.append(P)

      print("This took " + str(time.clock() - clockstart) + "s")
      return AllPoints
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[5]:
:END:

** Test:
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
    SpeciesDict = dict()

    SpeciesDict = {'Sp1': {'File': './data/average-european-diet/Bacteroides_sp_1_1_14.xml', 'initAbundance': 0.01},
   'Sp10': {'File': './data/average-european-diet/Desulfovibrio_piger_ATCC_29098.xml',
    'initAbundance': 0.01},
   'Sp2': {'File': './data/average-european-diet/Ruminococcus_flavefaciens_FD_1.xml',
    'initAbundance': 0.01},
   'Sp3': {'File': './data/average-european-diet/Lactobacillus_brevis_ATCC_367.xml',
    'initAbundance': 0.01},
   'Sp4': {'File': './data/average-european-diet/Mycobacterium_avium_subsp_avium_ATCC_25291.xml',
    'initAbundance': 0.01},
   'Sp5': {'File': './data/average-european-diet/Actinomyces_viscosus_C505.xml',
    'initAbundance': 0.01},
   'Sp6': {'File': './data/average-european-diet/Exiguobacterium_aurantiacum_DSM_6208.xml',
    'initAbundance': 0.01},
   'Sp7': {'File': './data/average-european-diet/Arcanobacterium_haemolyticum_DSM_20595.xml',
    'initAbundance': 0.01},
   'Sp8': {'File': './data/average-european-diet/Streptococcus_intermedius_JTH08.xml',
    'initAbundance': 0.01},
   'Sp9': {'File': './data/average-european-diet/Bifidobacterium_longum_infantis_ATCC_15697.xml',
    'initAbundance': 0.01}} 

  # {
  #       # 'H': {'File':'../../Recon3D_301_SBML/Recon3D_301.xml',
  #       #         'initAbundance': 0.01},
  #       'Sp1': {'File':'./data/average-european-diet/Bacteroides_sp_1_1_14.xml',
  #               'initAbundance': 0.01},
  #       'Sp2': {'File':'./data/average-european-diet/Actinomyces_urogenitalis_DSM_15434.xml',
  #               'initAbundance': 0.01},
  #       'Sp3': {'File':'./data/average-european-diet/Bifidobacterium_longum_infantis_ATCC_15697.xml',
  #               'initAbundance': 0.01},
  #       'Sp4': {'File':'./data/average-european-diet/Desulfovibrio_piger_ATCC_29098.xml',
  #               'initAbundance': 0.01},
  #       'Sp5': {'File':'./data/average-european-diet/Exiguobacterium_aurantiacum_DSM_6208.xml',
  #               'initAbundance': 0.01},
  #       'Sp6': {'File':'./data/average-european-diet/Lactobacillus_brevis_ATCC_367.xml',
  #                  'initAbundance': 0.01},
  #       'Sp7': {'File':'./data/average-european-diet/Bacteroides_ovatus_ATCC_8483.xml',
  #       'initAbundance': 0.01},
  #       # 'Sp8': {'File':'./data/average-european-diet/Bacteroides_vulgatus_ATCC_8482.xml',
  #       # 'initAbundance': 0.01},
  #       # 'Sp9': {'File':'./data/average-european-diet/Bacteroides_fragilis_NCTC_9343.xml',
  #       # 'initAbundance': 0.01},
  #   }

    MediaDF = pd.read_csv('./data/VMH_HighFiber.tsv', sep='\t')

    Output = simulateCommunity(SpeciesDict, MediaDF)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[6]:
:END:

#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t :ipyfile ./obipy-resources/2018-04-23-7sp.png
plotBiomass(SpeciesDict, Output)
#+END_SRC

#+RESULTS:
:RESULTS:
# Out[7]:
[[file:./obipy-resources/2018-04-23-7sp.png]]
:END:


- 500 iterations took 136 s
- 300 iterations took 129s!
- 1000 iterations for 4 species simulated until 96 minutes took 255s
- 1000 iterations for 6 sp till 116 min took 335s
- 1000 iterations for 9 sp till 113min took 525s
- 2000 iterations for 9 sp till 85.7 min took 1021s


#+RESULTS:
:RESULTS:
0 - 3ea91c73-2ea8-4c5b-b8d9-cef546eaa446
:END:
#+BEGIN_SRC ipython :session :exports both :results raw drawer :async t
plotMetabolites(AllPoints)
#+END_SRC
